SOLID

클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리

SRP : 단일 책임 원칙 (Single responsibility principle)

-한 클래스는 하나의 책임만 가져야 한다.
-하나의 책임이라는 것은 모호하다.
-클수도있고, 작을 수 있다.
-문맥과 상황에 따라 다르다
-중요한 기준은 변경이다. 변경이 있을때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것
예) UI 변경, 객체의 생성과 사용을 분리

--jsp 파일 하나에 뷰, DB접근 로직이 한번에 있다면? 이게 유지 보수가 가능할까? 절대 아니지




****OCP : 개방-폐쇄 원칙 (Open/closed principle)****
소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
이런 거짓말 같은 말이? 확장을 하려면, 당연히 기존 코드를 변경?
-- 확장을 하려면 코드변경을 해야되는데 그걸 안한다는말
다형성을 활용하자
-- 자동차를 생각하자! 역할과 구현을 분리해서 생각을 하면 새로운 기능을 만들고 
끼워넣기만 하자!
인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
-- 새로운 하나를 만드니 기존 코드를 건들리지를 않는다.

지금까지 배운 역할과 구현의 분리를 생각해보자.


*******************************************************************************************
OCP 개발-폐쇄 원칙(문제점)
-MemberService 클라이언트가 구현 클래스를 직접 선택
-MemberRepository m = new MemmoryMemberRepository(); //기존 코드
-MemberRepository m = new JdbcMemberRepository(); //변경 코드
-구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다.
-분명 다형성을 사용했지만 OCP 원칙을 지킬 수 없다.
-이 문제를 어떻게 해결해야 하나?

이렇게 OCP 문제를 깨뜨리는 경우를 어떻게 해결해야되냐면,
객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.
이 별도의 역할을 스프링 컨테이너가 해주는 역할이다.
이 원칙을 지키기위해 DI, IOC 컨테이너들이 필요한것이다.
*******************************************************************************************


LSP : 리스코프 치환 원칙 (Liskov substitution principle)

-프로그램의 객체는 프로그램의 정확성을 깨드리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
-다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙,
인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요하다.
-단순히 컴파일에 성공하는 것을 넘어서는 이야기
예) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반, 느리더라도 앞으로 가야함



ISP : 인터페이스 분리 원칙 (Interface segregation principle)

-특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
--- 자동차란 인터페이스가 있다고 하자
그때, 운전과 관련된 인터페이스도 있고, 자동차 정비 관련된 인터페이스도 있다.
이럴때 자동차 인터페이스 하나만 있다고 하면 너무 크다.
이걸 운전 인터페이스, 정비 인터페이스로 구분을 한다.
이렇게 되면 사용자 클라이언트를 운전과 정비 각각의 클라이언트로 분리할 수 있다.
이렇게되면 예를 들어서 정비에 문제가 생기면 정비만 바꾸고 운전이 문제있으면 운전만 바꾸면 된다.
또한 기능이 많으면 복잡해지는걸 해소해준다.

-자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
-사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리
-분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음.
-인터페이스가 명확해지고, 대체가능서잉 높아진다.

특정 클라이언

DIP : 의존관계 역전 원칙 (Dependency inversion principle)

-프로그래머는 "추상화에 의존해야지 구체화에 의존하면 안된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나다.
-쉽게 이야기해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
-앞에서 이야기한 역할(Role)에 의존하게 해야 한다는 것과 같다. 객체 세상도 클라이언트가 인터페이스에 의존해야
유연하게 구현체를 변경할 수 있다. 구현체에 의존하게 되면 변경이 아주 어려워진다.



**********************************************************************
DIP : 의존관계 역전 원칙
그런데 OCP에서 설명한 MemberService는 인터페이스에 의존하지만, 구현 클래스도 동시에 의존한다.
MemberService 클라이언트가 구현 클래스를 직접 선택
MemberRepository m = new MemoryMemberRepository();
DIP 위반 : 추상화에 의존해야지 구체화에 의존하면 안된다.

의존이란? 내가 저코드에 대해서 알면 의존이라는  것인데
MemberService는 MemberRepository(인터페이스)만 아는게 아닌 new 를 통해 MemmoryMemberRepository 까지 안다는 것이다.
이것때문에 내가 MemoryMemberRepository 부분을 바꾸려 할때 코드도 바꿔야되는 것이다.



정리

객체 지향의 핵심은 다형성
다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다.
다형성만으로는 구현객체를 변경할때 클라이어트 코드도 함께 변경된다.
다형성 만으로는 OCP, DIP를 지킬수 없다.
뭔가 더 필요하다.

